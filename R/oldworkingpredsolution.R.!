# > pred.solution
# function(dat,tgmean,tgerr=NULL,xeps=0.001,pcnr,additive=FALSE, maxarea=NULL, ptchoice=1, useweights=TRUE, mknormweights=F, allpts=F, gr2retlimit=TRUE,bpcenter=F,mindeg=0,...) {
#   # Datenstrukturen für tgmean, tgerr, maxarea handlen
#   tgmean<-matrix(tgmean,nrow=1)
#   if (!is.null(tgerr)) {
#     tgerr <- matrix(tgerr,nrow=1)
#   } else tgerr <- matrix(NA,nrow=1,ncol=length(tgmean))
#   #tgerr<- ifelse(!is.null(tgerr), matrix(tgerr,nrow=1), matrix(NA,nrow=1,ncol=length(tgmean)))
#   #WARNUNG wenn DIMENSION nich tzu tgmean passt??
#   #dimension von x und y
#   #  if (is.vector(dat$y)) {Ydim <- 1} else {Ydim <- dim(dat$y)[2]}
#   #  if (is.vector(dat$x)) {Xdim <- 1} else {Xdim <- dim(dat$x)[2]}
#
#   if (is.matrix(maxarea)) {
#     xdim <- dim(dat)[2]-dim(tgmean)[2]
#     if (dim(maxarea)[1] != xdim |  dim(maxarea)[2] != 2)
#       stop("wrong dimensions of maxarea in pred.solution")
#   } else if (!is.null(maxarea)) stop("maxarea must be matrix or NULL in pred.solution")
#
#   # initialisiere PI; Ydim, Xdim; xmeans, xsds
#   PI <- data.frame(pi.l=numeric(), pi.r=numeric(), pc=integer(), nr=integer())
#   Ydim <- length(tgmean)
#   if (is.matrix(dat)||is.null(dat$y)||is.null(dat$x)) dat <- data.frame(x=I(as.matrix(dat[,1:(dim(dat)[2]-Ydim)])), y=I(as.matrix(dat[,-(1:(dim(dat)[2]-Ydim))])))
#   Xdim <- dim(dat$x)[2]
#   # DIMENSIONSREDUKTION X
#   xmeans <- colMeans(dat)
#   xsds <- apply(dat,2,sd)
#   # DIMENSIONSREDUKTION Y # tg pca
#   if (Ydim>1) {
#     myypca <- tgpca(dat$y,tgmean,tgerr)
#     y1d <- myypca$pca$x[,"PC1",drop=F]
#     tgmean_norm <- myypca$pcatg[,"PC1"]
#     tgerr_norm <- myypca$pcatgerr[,"PC1"]
#   } else {
#     y1d <- dat$y
#     tgmean_norm <- tgmean[[1]]
#     #tgerr_norm <- ifelse(!is.na(tgerr), tgerr[[1]], NA)
#     if (!anyNA(tgerr)) tgerr_norm <- tgerr[[1]]+3 else tgerr_norm <- NA
#   }
#   # PLS
#   pls1 = plsdepot::plsreg1(dat$x, y1d, comps = Xdim)
#   # Daten eindimensional für jede HK im Liste betrachten
#   dat1d.PC12 <- list()
#   for (jjj in pcnr) {
#     dat1d.PC12[[jjj]] <- data.frame(x=pls1$x.scores[,paste0("t",jjj)], y=as.numeric(y1d))
#   }
#   # extended version - nur shift-liste # 1d punkt plus shift korrektur (für additive mit weights)
#   newx1d.PC12.ext <- list()
#   # für jede HK eindimensionale Vorhersage treffen
#   newx1d.PC12 <- list()
#
#   # benutze modelle
#   modeg <- NULL
#
#   #Gewichte bestimmen #### unklar was der Algorithmus bei bpcenter=T macht! warum zentrieren mit bestem punkt? Käse?
#   if (useweights==TRUE) {
#     if (bpcenter==F ) {
#       weightsall <- (1/euclw(pls1$x.scores, mknormweights))^2 # ^1 oder ^2?
#     } else { #sweep(matrix(0:2, nrow = 3, ncol=2), 2, c(0,10))
#       # dat$x - tgmean mit apply oder sweep
#       tmp1 <- sweep(dat$x,2,as.numeric(tgmean))
#       tmp1 <- sqrt(rowSums( tmp1^2 ))
#       #finde min abstand
#       minpoint <- pls1$x.scores[which.min(tmp1),]
#       weightsall <- (1/pmax(euclw(sweep(pls1$x.scores,2,minpoint), mknormweights),0.001))^2
#     }
#   } else weightsall=NULL
#   if (0<length(weightsall)) {
#     if (0<sum(is.infinite(weightsall))) warning("pred.solution: infinite weights were clipped")
#     weightsall[is.infinite(weightsall)]<-1e+300    #1.797693e+308
#   }
#
#   for (jjj in pcnr) {
#     if (sum(!is.na(weightsall[,jjj]))==0) warning("no non-NAs in pred.solution for weightsall[,jjj] (with mknormweights=T?) - degByBIC will probably fail in next line")
#     degjjj <- degByBIC(dat1d.PC12[[jjj]], weights=weightsall[,jjj], mindeg=mindeg)
#     modeg <- c(modeg, degjjj)
#     newx1d.PC12[[jjj]] <- getroots2(dat1d.PC12[[jjj]],
#                                     degjjj,
#                                     tgmean_norm,
#                                     limit=1.6*diff(range(dat1d.PC12[[jjj]]$x)), weights=weightsall[,jjj],retlimit = gr2retlimit)#weights)
#     if (additive==TRUE) {
#       # hier schleife. für jeden punkt)
#       if (length(newx1d.PC12[[jjj]])==0) {
#         newx1d.PC12.ext[[jjj]]<-list(NULL)
#       } else { # Punkte verbessern! jeden punkt...
#         for (ipnts in 1:length(newx1d.PC12[[jjj]])) { # length, denn immer eindimensional bzw dimensionslos
#           # warum nicht setdiff(pcnr,jjj)
#           shift <- list(); for (ishift in pcnr) shift[[ishift]] <- 0 # shift initialisieren mit 0
#           shift[[jjj]] <- newx1d.PC12[[jjj]][ipnts]                                          ###falsch wenn mehere punkte????? NUR ! PLATZ ZUM SPEICHERN!
#           # subschleife# dann punkt verbessern in richtung dimension lll              #### shift f mehr pkte nicht implementiert sinnvoll
#
#           #gewicht für datenpunkte minus shift
#           if (useweights==TRUE) weightsadd <- (1/euclw(sweep(pls1$x.scores, 2, unlist(shift)), mknormweights))^2 else weightsadd=NULL # ^1 oder ^2?
#           weightsadd[is.infinite(weightsadd)]<-1e+300    #1.797693e+308
#
#           for (lll in setdiff(pcnr,jjj)) { # korrigiere punkt in jeder richtung lll
#             #   # schaue jetzt in dimension lll - wie weit weg sind alle punkte von dimensionsgeraden lll?
#             #    if (useweights==TRUE) { #über abstände
#             #      weights <- rep(0,nrow(dat1d.PC12[[lll]])) # gewichte für alle punkte
#             #      for (kkk in setdiff(pcnr,lll)) {
#             #        weights <- weights+(dat1d.PC12[[kkk]]$x-shift[[kkk]])^2
#             #      }
#             #      weights <- sqrt(weights) # eucl distance     # weights distances from dim lll at predicted point
#             #      #weights <- (1/mknorm(weights))^2
#             #      #addinf for doím lll
#             #    } else {
#             #      weights<-NULL }
#             #    if (!is.null(weights)) if (mknormweights) weights <- abs(1/mknorm(weights))^1 else weights <- (1/weights)^2
#             # punkt bestimmen in richtung lll
#             if (!exists("weightsadd")) stop("weightsadd missing in pred")
#             weights <- weightsadd[,paste0("t",lll)] # passt das mit paste0 t für HKs?
#             if (!exists("weights")) stop("weights missing in pred")
#             newlll <- getroots2(dat1d.PC12[[lll]],
#                                 degByBIC(dat1d.PC12[[lll]], mindeg=mindeg),
#                                 tgmean_norm,
#                                 limit=1.6*diff(range(dat1d.PC12[[lll]]$x)), weights=weights, retlimit=TRUE)  ## achtung, statt 0 bei limitüberschreitung limit zurückkriegen
#             rm(weights)   # ^^^FEHLER???müsste für obere zeile mit weights nicht useweights==T sein? evtl. , evtl nicht, es könnte sein, dass weightsadd[,paste0("t",lll)] == NULL oder NA??
#             newlll <- ifelse(test = length(newlll)==0, 0, newlll) # wenn keine NP dann kein Shift
#             shift[[lll]] <- newlll############# erst punkt bestimmen
#             newx1d.PC12.ext[[jjj]] <- shift   ### ohoh!!!!!!!!!!!!!!! liste von listen oder besser unlist?
#           }
#         }
#       }#end else
#     }#end if additive
#     #Varianzkriterium? tgerr ode tgerr_norm
#     PI.mima <- t(PIhcheck(polymodel(dat1d.PC12[[jjj]],degByBIC(dat1d.PC12[[jjj]],weights=weightsall[,jjj], mindeg=mindeg),weights=weightsall[,jjj])))
#     #   message("Prädiktions-Intervallbreite für PC",jjj," in [", PIhcheck(polymodel(dat1d.PC12[[jjj]],degByBIC(dat1d.PC12[[jjj]], mindeg=mindeg)))[1],",",PIhcheck(polymodel(dat1d.PC12[[jjj]],degByBIC(dat1d.PC12[[jjj]], mindeg=mindeg)))[2],"]")
#     if(!anyNA(tgerr_norm)) {
#       if (PIhcheck(polymodel(dat1d.PC12[[jjj]],degByBIC(dat1d.PC12[[jjj]],weights=weightsall[,jjj], mindeg=mindeg),weights=weightsall[,jjj]))[1]>2*tgerr_norm & !anyNA(tgerr)) {
#         is2high <- 1
#         # #if (vartoobig==-1) {vartoobig<-i}
#         # warning("Varianz zu groß. Prädiktions-Intervallbreite von [", PIhcheck(polymodel(dat1d.PC12[[jjj]],degByBIC(dat1d.PC12[[jjj]], mindeg=mindeg))),"]>",2*tgerr_norm)
#         # #     warning("Varianz zu groß. Prädiktions-Intervallbreite: ", 2*qnorm(1-0.05/2)*sqrt(ssw(dat)),">",2*tgerr)
#       } else is2high <- 0
#     } else {warning("pred.sol: there is NA in tgerr_norm in prediction function"); is2high<-NA}
#     PI <- rbind(PI, cbind(PI.mima,jjj,is2high))
#   }
#   isprediction <- list()
#   # Alle Richtungen erzwingen? Ja!
#   if (FALSE) { # dont force solutions in all PC directions
#     # if (length(unlist(newx1d.PC12))==0 ) {
#     #   message(paste0("Schritt ",i,": gewähltes Modell findet keine Nullstellen in keiner Richtung. Messe an neuem Punkt außerhalb des bisherig betrachteten Bereichs."))
#     #   for (jjj in pcnr) {
#     #     if (min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==min(dat1d.PC12[[jjj]]$x)]-tgmean_norm)) < min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==max(dat1d.PC12[[jjj]]$x)]-tgmean_norm))) {
#     #       newx1d.PC12[[jjj]] <- min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#     #     }
#     #     else {
#     #       newx1d.PC12[[jjj]] <- max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#     #     }
#     #   }
#     # }
#   } else {
#     for (jjj in pcnr) {
#       if (length(newx1d.PC12[[jjj]])==0 ) {
#         isprediction[[jjj]] <- FALSE
#         #        # hier neuen punkt in richtung wählen - bräuchten alle projektionen auf hauptkomponente um größte lücke zu finden
#         #        cat("1d points avail.:",paste(" ",sort(c(0, unique(dat1d.PC12[[jjj]][[1]])))))
#         #        cat("1d points avail.:",paste(" ",diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))))))
#         #        #alle neuen möglichen messpunkte:
#         #        #cat("meas at:",paste(" ", head( sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))))*0.5))
#         #        cat("meas at:",paste(" ", head( sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))))*0.5))
#         #        cat("ext points",
#         #            min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2,
#         #            " and ",
#         #            max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2)
#         if (ptchoice==1) { # punkt aussen suchen, macht nur begrenzt sinn, wenn grnzen für parameter existieren
#           #message(paste0("Schritt ","i",": gewähltes Modell findet keine Nullstellen in Richtung PC ",jjj,". Messe an neuem Punkt außerhalb des bisherig betrachteten Bereichs."))
#           if (min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==min(dat1d.PC12[[jjj]]$x)]-tgmean_norm)) < min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==max(dat1d.PC12[[jjj]]$x)]-tgmean_norm))) {
#             newx1d.PC12[[jjj]] <- min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           } else {
#             newx1d.PC12[[jjj]] <- max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           }
#         } else if (ptchoice==2) { # die 0 macht innerhalb von sort wenig sinn, oder?
#           newx1d.PC12[[jjj]] <- c((head( sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))))*0.5)[which.max(diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]])))))],
#                                   min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2,
#                                   max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           )
#         } else if (ptchoice==20) { # wie oben, aber ohne 0,  d.h. suche innen (1 Punkt) und am Rand (2Punkte)
#           newx1d.PC12[[jjj]] <- c((head( sort(c(unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(unique(dat1d.PC12[[jjj]][[1]]))))*0.5)[which.max(diff(sort(c(unique(dat1d.PC12[[jjj]][[1]])))))],
#                                   min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2,
#                                   max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           )
#         } else if (ptchoice==200) { # aber innen (1 Punkt) und am Rand (1Punkt)
#           if (min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==min(dat1d.PC12[[jjj]]$x)]-tgmean_norm)) < min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==max(dat1d.PC12[[jjj]]$x)]-tgmean_norm))) {
#             tmp <- min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           } else {
#             tmp <- max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#           }
#           newx1d.PC12[[jjj]] <- c((head( sort(c(unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(unique(dat1d.PC12[[jjj]][[1]]))))*0.5)[which.max(diff(sort(c(unique(dat1d.PC12[[jjj]][[1]])))))],
#                                   tmp)
#         } else if (ptchoice==3) {# nur 1 punkt für max abstand
#           # #measureatpts <- head( sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]]))))*0.5
#           # #choosept <- which.max(diff(sort(c(0, unique(dat1d.PC12[[jjj]][[1]])))))
#           # #newx1d.PC12[[jjj]] <- measureatpts[choosept]
#           # measureatpts <- head( sort(c(unique(dat1d.PC12[[jjj]][[1]]))) ,-1) + diff(sort(c(unique(dat1d.PC12[[jjj]][[1]]))))*0.5
#           # choosept <- which.max(diff(sort(c(unique(dat1d.PC12[[jjj]][[1]])))))
#           # newx1d.PC12[[jjj]] <- measureatpts[choosept]
#           # #
#           if (!is.null(maxarea)) {
#             xcols <- grep("x.", names(xmeans), value = TRUE)
#             mima <- mimascores(t(mknorm(t(maxarea),xmeans[xcols],xsds[xcols])), pls1$mod.wgs)[jjj,]
#             upts <- unique(dat1d.PC12[[jjj]][[1]])  # wofür ist die [[1]]?
#             upts <- upts[which(upts>mima[1])] # im intervall?
#             upts <- upts[which(upts<mima[2])]
#             upts <- sort(c(upts, mima)) # mit mima-Grenzen und sortiert
#
#             measureatpts <- head(upts ,-1) + diff(upts)*0.5
#             # wenn rand gegeben, dann wähle als abstand  2*(kleinstervorkommenderxwert-minpossiblexval) bzw
#             #                                           2*(groestervorkommenderxwert-maxpossiblexval)
#             if (length(upts)<2) stop("impossible: length(upts)<2 für ptchoice3")
#             if (length(upts)<3) {
#               warning("unhandled: length(upts)<3 für ptchoice3")
#               choosept <- 1 # mal probieren, müsste passen
#             } else choosept <- which.max(diff(upts)* c(2,rep(1,length(upts)-3),2)  )
#             newx1d.PC12[[jjj]] <- measureatpts[choosept]
#
#             if (anyNA(newx1d.PC12[[jjj]])){
#               xcols <- grep("x.", names(xmeans), value = TRUE)
#               print(maxarea)
#               #print(xcols)
#               #print(xmeans[xcols])
#               #print(xsds[xcols])
#               print(mknorm(t(maxarea),xmeans[xcols],xsds[xcols]))
#               print(mima)
#               print(newx1d.PC12[[jjj]])
#               ttt<-unique(dat1d.PC12[[jjj]][[1]])
#               # print(ttt)
#               ttt <- ttt[which(ttt>mima[1])] # im intervall?
#               #  print(ttt)
#               ttt <- ttt[which(ttt<mima[2])]
#               print(ttt)
#               print(upts)
#               # print(measureatpts)
#               print(choosept)
#               #print(plot(pls1$x.scores%*%solve(pls1$mod.wgs)))
#               plot(pls1$x.scores%*%solve(pls1$mod.wgs),xlim=c(-9,9),ylim=c(-9,9))
#               points(pls1$x.scores[,1,drop=F]%*%solve(pls1$mod.wgs)[1,,drop=F],col="green")
#               points(matrix(mima)%*%solve(pls1$mod.wgs)[1,,drop=F],col="red")
#               plot(mkreg(pls1$x.scores%*%solve(pls1$mod.wgs),xmeans[xcols],xsds[xcols]),xlim=c(-30,30),ylim=c(-30,30))
#               points(mkreg(pls1$x.scores[,1,drop=F]%*%solve(pls1$mod.wgs)[1,,drop=F],xmeans[xcols],xsds[xcols]),col="green")
#               points(mkreg(matrix(mima)%*%solve(pls1$mod.wgs)[1,,drop=F],xmeans[xcols],xsds[xcols]),col="red")
#               rm(xcols)
#               stop("newx1d.PC12[[jjj]] hat NA in prediction")
#             }
#           } else { # wenn keine grenzen dann wie ptchoice1
#             if (min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==min(dat1d.PC12[[jjj]]$x)]-tgmean_norm)) < min(abs(dat1d.PC12[[jjj]]$y[dat1d.PC12[[jjj]]$x==max(dat1d.PC12[[jjj]]$x)]-tgmean_norm))) {
#               newx1d.PC12[[jjj]] <- min(dat1d.PC12[[jjj]]$x) - (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#             } else {
#               newx1d.PC12[[jjj]] <- max(dat1d.PC12[[jjj]]$x) + (max(dat1d.PC12[[jjj]]$x) - min(dat1d.PC12[[jjj]]$x))/2
#             }
#           }
#         }
#       } else isprediction[[jjj]] <- TRUE
#     }
#   }#end else
#   # Vom 1D in den xdim-D: newx1d -> newx
#   xcols <- grep("x.", names(xmeans), value = TRUE)
#   newx.PC12 <- list()
#   if (additive==TRUE) { if(FALSE){
#     # newx1d.add <- NULL #besser sowas? matrix(nrow=length(newx1d.PC12[[pcnr[1]]]),ncol=0)
#     # for (jjj in pcnr) {
#     #   newx1d.add <- cbind(newx1d.add,newx1d.PC12[[jjj]])
#     # } # oben evtl. besser als code unten, da es mit dimension 1 funktioniert?
#     newx1d.add <- newx1d.PC12[[pcnr[1]]]
#     for (jjj in pcnr[-1]) {
#       newx1d.add <- cbind(newx1d.add,newx1d.PC12[[jjj]])
#     }
#     tpcnr <- c(1)
#
#     #hier jetzt aber auch die nicht additiven punkte mitnehmen
#     tpcnr <- c(pcnr,max(pcnr)+1)
#     #der not additive teil:
#     for (jjj in pcnr) { warning("nr1")
#       newx.PC12[[jjj]] <- mkreg(matrix(newx1d.PC12[[jjj]])%*%solve(pls1$mod.wgs)[jjj,],xmeans[xcols],xsds[xcols])
#     }
#     # der additive teil
#     newx.PC12[[max(pcnr)+1]] <- mkreg(newx1d.add%*%solve(pls1$mod.wgs)[pcnr,],xmeans[xcols],xsds[xcols])}
#     # wir müssen hier die neuen shifts berücksichtige unten beim rücktransformieren
#     tpcnr <- pcnr
#     for (jjj in pcnr) {
#       if (is.null(unlist(newx1d.PC12.ext[[jjj]]))) {
#         # newx.PC12[[jjj]] <- NULL # leer lassen oder
#         newx.PC12[[jjj]] <- list(NULL) # liste 0?
#       } else {
#         if (allpts==T) { warning("nr2")
#           newx.PC12[[jjj]] <- rbind(mkreg(t(unlist(newx1d.PC12.ext[[jjj]]))%*%solve(pls1$mod.wgs)[pcnr,],xmeans[xcols],xsds[xcols]),
#                                     mkreg(matrix(newx1d.PC12[[jjj]])%*%solve(pls1$mod.wgs)[jjj,],xmeans[xcols],xsds[xcols]))  # normalen punkt mitnehmen
#         } else {
#           newx.PC12[[jjj]] <- mkreg(t(unlist(newx1d.PC12.ext[[jjj]]))%*%solve(pls1$mod.wgs)[pcnr,],xmeans[xcols],xsds[xcols]) # nur den guten nehmen
#         }
#       }
#     }
#   } else { # end if additive
#     tpcnr <- pcnr
#     for (jjj in pcnr) {warning("nr3")
#       newx.PC12[[jjj]] <- mkreg(matrix(newx1d.PC12[[jjj]])%*%solve(pls1$mod.wgs)[jjj,],xmeans[xcols],xsds[xcols])
#     }
#   }
#   ###nur bestimmen, wenn neue Punkte um mehr als xeps verschieden
#   ## PC12schleife
#   dstncs.PC12 <- list()
#   for (jjj in tpcnr) {
#     if (is.null(unlist(newx.PC12[[jjj]]))) { ## für den rest der schleife tpcnr == jjj ignorieren
#       tpcnr <- setdiff(tpcnr,jjj)
#     } else {
#       ###nur bestimmen, wenn neue Punkte um mehr als xeps verschieden
#       dstncs.PC12[[jjj]] <- matrix(nrow = dim(newx.PC12[[jjj]])[1],ncol=dim(dat$x)[1])
#       #folgende Zeile nur wenn überhaupt punkte vorhanden in PCjjj:
#       if (dim(newx.PC12[[jjj]])[1]>0)
#         for (cnt in 1:dim(newx.PC12[[jjj]])[1]) {
#           dstncs.PC12[[jjj]][cnt,] <- mvdistance(dat$x, newx.PC12[[jjj]][cnt,])
#         }
#     }
#   }
#   for (jjj in tpcnr) {
#     newx.PC12[[jjj]] <- newx.PC12[[jjj]][ suppressWarnings(apply(dstncs.PC12[[jjj]],1,min))>xeps ,,drop=F]
#   }
#   newx<-NULL
#   is.prediction <- numeric(0)
#   for (jjj in tpcnr) {
#     newx <- rbind(newx,newx.PC12[[jjj]] )
#     is.prediction <- c(is.prediction, rep(isprediction[[jjj]],nrow(newx.PC12[[jjj]])))
#     ##newx <- rbind(newx,c(newx.PC12[[jjj]], ifelse(is.null(isprediction[[jjj]]),NA,isprediction[[jjj]])) )
#   }
#   #colnames(newx)<-c(colnames(dat$x),"is.prediction") # use names of coloumns
#   return(list(newx=newx, dat1d.PC12=dat1d.PC12, newx1d.PC12=newx1d.PC12,  is.prediction = is.prediction, isprediction=isprediction, PI=PI, modeg=modeg))#cbind(PI, is.prediction, unlist(isprediction))))
# }
# <environment: namespace:mvTargetOpt>
